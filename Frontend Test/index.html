<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js Test</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }

        .canvasOverlay {
            position: fixed;
            left: 0;
            top: 0;
            color: white;
            font-family: sans-serif;
        }

        .canvasOverlay > h1 {
            margin: 0;
            padding: 20px;
        }
    </style>
</head>
<body onresize="onWindowResize()">
<script src="js/threejs/build/three.min.js"></script>
<script src="js/threejs/controls/OrbitControls.js"></script>
<script src="js/threejs/loaders/GLTFLoader.js"></script>
<script src="js/datgui/dat.gui.min.js"></script>
<div class="canvasOverlay">
    <h1 id="scale"></h1>
</div>
<script>
    // Dummy Map data to test on before we add in
    mapData = [
        {
            "objectId": 0,
            "pos": {
                "x": 0.0,
                "y": 0.0,
                "z": 0.0
            },
            "modelPath": "Assets/models/Neptune/",
            "objectInfo": {
                "Object": "Planet",
                "Type": "Gas Giant"
            },
            "scale": 11144.9,
            "name": "Eos"
        },
        {
            "scale": 0.001,
            "name": "Eos 222",
            "objectId": 1,
            "pos": {
                "x": 15000.0,
                "y": 0.0,
                "z": 0.0
            },
            "modelPath": "Assets/models/Station/",
            "objectInfo": {
                "Object": "Station",
                "Type": "Neutral"
            }
        }
    ];

    let asteroidsToLoad = 12;

    let asteroidA = loadNewAsteroid(["Assets/models/Asteroids/a4.gltf", "Assets/models/Asteroids/a3.gltf", "Assets/models/Asteroids/a2.gltf", "Assets/models/Asteroids/a1.gltf"]);
    let asteroidB = loadNewAsteroid(["Assets/models/Asteroids/b4.gltf", "Assets/models/Asteroids/b3.gltf", "Assets/models/Asteroids/b2.gltf", "Assets/models/Asteroids/b1.gltf"]);
    let asteroidC = loadNewAsteroid(["Assets/models/Asteroids/c4.gltf", "Assets/models/Asteroids/c3.gltf", "Assets/models/Asteroids/c2.gltf", "Assets/models/Asteroids/c1.gltf"]);

    const asteroidLODs = [
        asteroidA,
        asteroidB,
        asteroidC
    ];

    // Define standard three.js objects required to make scene function properly
    const scene = new THREE.Scene(); // Scene itself, contains all objects
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, Math.pow(10, 0), Math.pow(10, 6)); // Camera using a perspective view (as opposed to orthographic. Aspect ratio set to match window and camera renders from 0.1 units away to 10^6 units away.
    const renderer = new THREE.WebGLRenderer({antialias: true}); // Three.js renderer. The actual web element (canvas object) if I'm not mistaken?
    const controls = new THREE.OrbitControls(camera, renderer.domElement); // Uses standard orbit controls to manipulate the camera's movement. Might change it to be more like E:D at some point but this works for now.
    let settings = {
        zoomIncrement: 10, // The factor that the grid is scaled by. By default it is 10, i.e. 1x1 grid -> 10x10 grid -> 100x100 grid
        asteroidCount: 1000 // The number of asteroids to render around Eos
    };

    let asteroids = [];
    let spawnedAsteroids = 0;

    for (let mapObject in mapData) {
        // noinspection JSUnfilteredForInLoop *because JSON Validation is way easier*
        let {name, scale, objectId, pos, modelPath, objectInfo} = mapData[mapObject];

        let loader = new THREE.GLTFLoader();

        loader.load(modelPath + 'scene.gltf', (gltf) => {
            gltf.scene.scale.set(scale, scale, scale);
            gltf.scene.position.set(pos.x, pos.y, pos.z);
            scene.add(gltf.scene);
        }, undefined, (err) => {
            console.error(err)
        });
    }


    renderer.setSize(window.innerWidth, window.innerHeight); // Set renderer object (canvas element) to match window size
    document.body.appendChild(renderer.domElement); // Add the canvas element to the page.

    // Load in a space cube map at Assets/skybox/ to act as a backdrop.
    scene.background = new THREE.CubeTextureLoader()
        .setPath('Assets/skybox/')
        .load([
            'right.png', //     positive x
            'left.png', //      negative x
            'top.png', //       positive y
            'bottom.png', //    negative y
            'front.png', //     positive z
            'back.png' //       negative z
        ]);

    // Define a directional light source coming from approximately where the main star is on the cubemap
    scene.sun = new THREE.DirectionalLight(0xffffff, 0.9);
    scene.sun.position.set(-1, -0.15, -0.1);
    scene.add(scene.sun);

    // Add a soft ambient light source to illuminate objects indirectly, as if from other smaller stars.
    scene.stars = new THREE.AmbientLight(0x404040, 0.5);
    scene.add(scene.stars);

    // Add a grid that spans 1000 squares, each 1x1 unit.
    let gridHelper = new THREE.GridHelper(1000, 1000);
    scene.add(gridHelper);

    // Position the camera above and behind the scene.
    camera.position.set(0, 4000, 20000);
    controls.update();

    // Animate subroutine, called each frame to update the scene.
    const animate = function () {
        // Schedule a new frame at the monitor's refresh rate
        requestAnimationFrame(animate);

        // Find the distance from the camera to the point it orbits around
        let cameraFocus = controls.target;
        let cameraPosition = camera.position;
        let cameraZoomDistance = cameraPosition.distanceTo(cameraFocus);

        // Define a "Zoom Factor" by taking the logarithm of the zoom distance divided by five, in the base of the increment defined earlier in the settings object.
        let zoomFactor = Math.floor(Math.log(cameraZoomDistance) / Math.log(settings.zoomIncrement));

        // Dynamically set camera near/far plane
        camera.near = (Math.pow(settings.zoomIncrement, zoomFactor) / 1000);
        camera.far = (Math.pow(settings.zoomIncrement, zoomFactor) * 1000);
        camera.updateProjectionMatrix();

        // Ensure number of asteroids rendered matches setting
        while (spawnedAsteroids !== settings.asteroidCount && asteroidsToLoad === 0) {
            if (asteroids.length < settings.asteroidCount) {
                // Add more asteroids
                let lod = asteroidLODs[Math.floor(Math.random() * asteroidLODs.length)];
                lod = lod.clone();

                let radius = 14000 + Math.random() * 2200;
                let angle = Math.random() * 2 * Math.PI;
                lod.position.set(Math.cos(angle) * radius + (Math.random() - 0.5) * 1000, (Math.random() - 0.5) * 1000, Math.sin(angle) * radius + (Math.random() - 0.5) * 1000);
                lod.scale.set((Math.random() + 0.5) * 100, (Math.random() + 0.5) * 100, (Math.random() + 0.5) * 100);
                lod.rotation.set(Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI);
                lod.rotationAmounts = new THREE.Vector3(Math.random() * 0.0075, Math.random() * 0.0075, Math.random() * 0.0075);
                asteroids.push(lod);
                scene.add(asteroids[asteroids.length - 1]);

                spawnedAsteroids++;
            } else if (asteroids.length > settings.asteroidCount) {
                // Remove some asteroids
                scene.remove(asteroids.pop());
                spawnedAsteroids--;
            }
        }

        // Rotate the asteroids
        for (let asteroid in asteroids) {
            // noinspection JSUnfilteredForInLoop *Shut up WebStorm*
            asteroids[asteroid].rotation.x += asteroids[asteroid].rotationAmounts.x;
            // noinspection JSUnfilteredForInLoop *Shut up WebStorm*
            asteroids[asteroid].rotation.y += asteroids[asteroid].rotationAmounts.y;
            // noinspection JSUnfilteredForInLoop *Shut up WebStorm*
            asteroids[asteroid].rotation.z += asteroids[asteroid].rotationAmounts.z;
        }

        // Output a scale in text to a h1 element on top of the canvas
        document.getElementById("scale").innerText = "1 Grid Tile = " + Math.pow(settings.zoomIncrement, zoomFactor).toString() + "km Ã— " + Math.pow(settings.zoomIncrement, zoomFactor).toString() + "km.";

        // Scale the grid to match the zoom factor, that is to say, scale it by zoom Increment raised to the power of zoom Factor
        gridHelper.scale.set(Math.pow(settings.zoomIncrement, zoomFactor), Math.pow(settings.zoomIncrement, zoomFactor), Math.pow(settings.zoomIncrement, zoomFactor));

        // Update controls system each frame to prevent issues when moving camera or resizing window
        controls.update();

        // Render this frame.
        renderer.render(scene, camera);
    };

    // Manually call the first frame to be animated
    animate();

    function onWindowResize() {

        // Reset the camera and viewport to match the window dimensions if it is resized.
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    window.onload = () => {
        const gui = new dat.GUI();
        gui.add(settings, "zoomIncrement").min(2).max(20).step(1);
        gui.add(settings, "asteroidCount").min(0).max(10000).step(1);
    };

    function loadNewAsteroid(model) {
        let asteroidLoader = new THREE.GLTFLoader();

        let lod = new THREE.LOD();

        asteroidLoader.load(model[3], (gltf) => {
            lod.addLevel(gltf.scene.children[0], 100000);
            asteroidsToLoad--
        }, undefined, (err) => {
            console.error(err);
        });

        asteroidLoader.load(model[2], (gltf) => {
            lod.addLevel(gltf.scene.children[0], 10000);
            asteroidsToLoad--
        }, undefined, (err) => {
            console.error(err);
        });

        asteroidLoader.load(model[1], (gltf) => {
            lod.addLevel(gltf.scene.children[0], 1000);
            asteroidsToLoad--
        }, undefined, (err) => {
            console.error(err);
        });

        asteroidLoader.load(model[0], (gltf) => {
            lod.addLevel(gltf.scene.children[0], 100);
            asteroidsToLoad--
        }, undefined, (err) => {
            console.error(err);
        });

        return lod;
    }
</script>
</body>
</html>