<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js Test</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }

        .canvasOverlay {
            position: fixed;
            left: 0;
            top: 0;
            color: white;
            font-family: sans-serif;
        }

        .canvasOverlay > h1 {
            margin: 0;
            padding: 20px;
        }
    </style>
</head>
<body onresize="onWindowResize()">
<script src="js/threejs/build/three.min.js"></script>
<script src="js/threejs/controls/OrbitControls.js"></script>
<script src="js/datgui/dat.gui.min.js"></script>
<div class="canvasOverlay">
    <h1 id="scale"></h1>
</div>
<script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, Math.pow(10, 6));
    const renderer = new THREE.WebGLRenderer();
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    let settings = {
        zoomIncrement: 10
    };

    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.background = new THREE.CubeTextureLoader()
        .setPath('Assets/skybox/')
        .load([
            'right.png',
            'left.png',
            'top.png',
            'bottom.png',
            'front.png',
            'back.png'
        ]);

    scene.sun = new THREE.DirectionalLight(0xffffff, 0.7);
    scene.sun.position.set(-1, -0.15, -0.1);
    scene.add(scene.sun);

    scene.stars = new THREE.AmbientLight(0x404040, 0.2);
    scene.add(scene.stars);

    let geometry = new THREE.BoxGeometry();
    let material = new THREE.MeshPhongMaterial({color: 0x00ff00});
    let cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    let gridHelper = new THREE.GridHelper(1000, 1000);
    scene.add(gridHelper);

    camera.position.set(0, 20, 100);
    controls.update();

    const animate = function () {
        requestAnimationFrame(animate);

        let cameraFocus = controls.target;
        let cameraPosition = camera.position;
        let cameraZoomDistance = cameraPosition.distanceTo(cameraFocus);
        let zoomFactor = Math.floor(Math.log((cameraZoomDistance / 5) / Math.log(settings.zoomIncrement)));
        document.getElementById("scale").innerText = "1 Grid Tile = " + Math.pow(settings.zoomIncrement, zoomFactor).toString() + "km Ã— " + Math.pow(settings.zoomIncrement, zoomFactor).toString() + "km.";
        gridHelper.scale.set(Math.pow(settings.zoomIncrement, zoomFactor), Math.pow(settings.zoomIncrement, zoomFactor), Math.pow(settings.zoomIncrement, zoomFactor));

        cube.rotation.x += 0.01;
        cube.rotation.y += 0.01;

        controls.update();

        renderer.render(scene, camera);
    };

    animate();

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    window.onload = () => {
        const gui = new dat.GUI();
        gui.add(settings, "zoomIncrement").min(2).max(20).step(1);
    }
</script>
</body>
</html>